func lang_spec() {
    let a u8
    let b u32

    let x i8
    let y i32

    // The +, -, *, /, and % operators require two operands of the same type.

    a = u8(255) + u8(1) // 0
    a = u8(255) + u8(2) // 1

    a = u8(1) - u8(3) // 254

    a = u8(13) * u8(23) // 43
    x = i8(-13) * i8(23) // -43

    a = u8(15) / u8(9) // 1

    a = u8(15) / u8(0) // PANIC

    x = i8(-128) / i8(-1) // -128

    a = u8(15) % u8(0) // PANIC

    x = i8(-128) % i8(-1) // 0

    // The >> and << operands require right the operand to be of type u8 or u32.

    a = u8(4) >> u32(1) // 2
    x = i8(-4) >> u32(1) // -2

    b = u32(4) >> u8(5) // 0
    y = i32(-4) >> u8(5) // -1

    b = u32(4) << u8(3) // 32
    y = i32(-4) << u32(3) // -32

    // If the value is a signed integer, it is sign extended to implicit
    // infinite precision; otherwise it is zero extended. It is then truncated
    // to fit in the result type's size.

    b = u32(0x10F0)
    a = i8(b)
    b = u32(a) // 0xFFFFFFF0

    // The ==, !=, <, <=, >, and >= operators require two operands of the same
    // type and yield a result of u8 type.

    // The && (logical AND) and || (logical OR) require two operands of u8 type
    // and yield a result of u8 type.

    // Built-in functions
    // su8(addr u32, val u8)
    // su32(addr u32, val u32)
    // si8(addr u32, val i8)
    // si32(addr u32, val i32)
    // lu8(addr u32) u8
    // lu32(addr u32) u32
    // li8(addr u32) i8
    // li32(addr u32) i32
    // ecall()

    // Memory map
    // 0x0001_0000 - 0x0001_ffff Ecall parameters
    // 0x1000_0000 - 0x1fff_ffff Instructions
    // 0x2000_0000 - 0x2fff_ffff Stack
    // 0x3000_0000 - 0x3fff_ffff Free memory for the program

    // String literals
    // Only ASCII printable characters are allowed in a string literal.
    // Escape sequences
    // \"
    // \\
    // \000
    // \x00

    b <- "ABC\000\123\xff\"\\"
}

func main() {
    lang_spec()
}
